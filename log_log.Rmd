---
title: "R Notebook"
output:
  word_document: default
  html_document:
    df_print: paged
---

```{r}
library(tidyverse)
library(ggfortify)
library(ggplot2)
library(readr)
library(dplyr)
library(viridis)
library(ggthemes)
library(DT)
library(magrittr)
library(qwraps2)
library(kableExtra)
library(ggalt)
library(WDI)
library(foreign)
library(GGally)
library(survival)

```




# BLR including WTP
```{r}
#data formatting 
choice <- read.csv("raw/version_to_package.csv", stringsAsFactors = TRUE) %>% 
  rename(survey_version = 1)

packages <- read.csv("raw/packages.csv", stringsAsFactors = TRUE)  %>% 
  rename(package = 1)

choice_package <- choice %>% 
  left_join(packages) %>% 
  mutate(choice = ifelse(package <= 16,1,2))


survey <- read.csv("raw/master_survey_resp.csv", stringsAsFactors = TRUE) %>% 
  select(survey_id, survey_version, country, choice, package_nopackage, starts_with("wtp"), starts_with("wtr"))

pack_yes <- survey %>% 
  filter(package_nopackage == 1) %>% 
  mutate(wtp = ifelse(wtp_4 == "y", 4,
                      ifelse(wtp_4 == "n", 3,
                             ifelse(wtp_3 =="n", 2,
                                    ifelse(wtp_2 =="n", 1, 0))))) %>% 
  select(-starts_with("wtp_"), -starts_with("wtr_"), -package_nopackage) %>% 
  left_join(choice_package) %>% 
  mutate(choice = 1)

pack_no <- survey %>% 
  filter(package_nopackage == 0) %>% 
  mutate(wtp = ifelse(wtr_4 == "y", -4,
                      ifelse(wtr_4 == "n", -5,
                             ifelse(wtr_3 =="y", -3,
                                    ifelse(wtr_2 =="y", -2, -1))))) %>% 
  select(-starts_with("wtp_"), -starts_with("wtr_"), -package_nopackage) %>% 
  left_join(choice_package) %>% 
  mutate(choice = 1)

pack_no_no <- pack_no %>% 
  mutate(wtp = (wtp + 1)) %>% 
  mutate(choice = 0)

pack_yes_no <- pack_yes %>% 
  filter(wtp != 4) %>% 
  mutate(wtp = (wtp + 1)) %>% 
  mutate(choice = 0)

bind_pre <- rbind(pack_no,pack_yes, pack_no_no, pack_yes_no) %>% 
  filter(wtp != -5)

other_pack <- bind_pre %>% 
  select(survey_id, survey_version, country,  choice) %>%
  mutate(choice = ifelse(choice == 1,2,1)) %>% 
  left_join(choice_package) %>% 
  mutate(choice = 0) %>% 
  mutate(wtp = 0)

bind <- rbind(bind_pre, other_pack) 

```

For IND

wtp_1 = $2.14
wtp_2 = $3.56
wtp_3 = $5.35
wtp_4 = $7.12

For MEX 

wtp_1 = $2.07
wtp_2 = $3.62
wtp_3 = $5.17
wtp_4 = $7.75

```{r}
#wtp == -5, -100, 
bind_ind <- bind %>% 
  filter(country =="IND") %>% 
  mutate(wtp = 
                      ifelse(wtp == -4, -7.12,
                       ifelse(wtp == -3, -5.35, 
                              ifelse(wtp == -2, -3.56,
                                      ifelse(wtp == -1, -2.14, 
                                             ifelse(wtp == 0, 0, 
                                                    ifelse(wtp == 1, 2.14, 
                                                           ifelse(wtp == 2, 3.56, 
                                                                  ifelse(wtp == 3, 5.35, 7.12)))))))))
#ifelse(wtp == -5, -100,
bind_mex <- bind %>% 
  filter(country =="MEX") %>% 
  mutate(wtp =
                    ifelse(wtp == -4, -7.75,
                       ifelse(wtp == -3, -5.17, 
                              ifelse(wtp == -2, -3.62,
                                      ifelse(wtp == -1, -2.07, 
                                             ifelse(wtp == 0, 0, 
                                                    ifelse(wtp == 1, 2.07, 
                                                           ifelse(wtp == 2, 3.62, 
                                                                  ifelse(wtp == 3, 5.17, 7.75)))))))))

bind_wtp <- rbind(bind_mex,bind_ind) %>% 
  mutate(own = as.factor(own))


#making the df to be used for log-log
bind_log <- bind_wtp %>% 
  filter(choice == 1) %>% 
  mutate(sos = ifelse(sos==1,0,1)) %>% 
  mutate(info = ifelse(info == 2,0,1)) %>% 
  mutate(own = as.factor(own)) 
mean(bind_log$wtp)
#write.csv(bind_log, "int/log_log_wtp.csv", row.names = FALSE)
```


```{r}
wtp_distribution <- bind %>% 
  filter(choice == 1) %>% 
  select(wtp) %>%
  mutate(wtp_p4 = wtp + 4) %>% 
  mutate(log_wtp = log(wtp_p4)) %>% 
  gather(variable, value) 
  
wtp_distribution %>% 
 ggplot(aes(x = value, fill = variable)) +
    geom_bkde() +
    geom_rug() +
    scale_fill_viridis(guide = FALSE, discrete = TRUE) +
    facet_wrap(~variable, scales = "free") +
    theme_base()

```



```{r}
variables <- read_csv("int/variables.csv")

variables_log <- variables %>% 
  select(survey_id, country, community, income, years_fishing, age, education, boat_status)
```

Adding variables Income, Education, Years Fishing, Age, Country, Fishing Organization Members, Biggest problem facing fishery, fishing technology exposure, boat ownership.

Outlier detection
```{r}

income_summary <-
  list("Monthly Income" =
       list("min" = ~ min(.data$income),
            "max" = ~ max(.data$income),
            "mean (sd)" = ~ qwraps2::mean_sd(.data$income)))

income_na <- variables %>% 
  select(community, income) %>% 
  na.omit() %>% 
  mutate(community = as.factor(community))
  
by_com <- summary_table(dplyr::group_by(income_na, community), income_summary)
kable(by_com)

#HUGE distribution of income in IND, especially in WKB (10^7 difference) min is a single digit number, which does not make sense for Indonesia (Annual income for lowest income would be $0.0043) 

#Fixing for Wkb income error & currency conversion 

#0.000071 USD / 1 Indonesian Rupiah 
#0.052 USD / 1 Medican Peso

income_fix <- variables %>% 
  select(survey_id, country, community, income) %>%
  mutate(income = ifelse(country == "IND" & income <= 10, income*1000000, income)) %>% 
  mutate(currency = ifelse(country=="MEX", 0.052, 0.000071)) %>% 
  mutate(income_usd = currency*income*12) %>% 
  mutate(income_usd = round(income_usd, digits = 2))

usd_com_mean <-income_fix %>% 
  group_by(community) %>% 
  summarise(mean_income = mean(income_usd, na.rm = TRUE))

#adding in GDP per Capita conversion 
gdp_raw <- WDI(indicator = "NY.GDP.PCAP.KD", country=c("MX", "ID"), start = 2018, end = 2018) %>% 
  mutate(country = ifelse(country=="Mexico", "MEX", "IND")) %>% 
  rename(c = 1) %>% 
  select(-c, -year)

variables_income_fix <- income_fix %>% 
  left_join(usd_com_mean) %>%
  mutate(gf_income = ifelse(is.na(income), 1, 0)) %>% 
  mutate(income_usd = ifelse(is.na(income), mean_income, income_usd)) %>% 
  left_join(gdp_raw) %>% 
  mutate(gdp_prop = income_usd/NY.GDP.PCAP.KD)

gdp_prop<-variables_income_fix %>% 
  select(survey_id, gdp_prop, income_usd, NY.GDP.PCAP.KD)
```

Income from fishing, percent-gap filled
```{r}
fishincome <- variables %>%
  select(survey_id, country, community, income_fishing) %>%
  group_by(community) %>%
  summarise(mean_fishincome = round(mean(income_fishing, na.rm = TRUE),0))

variables_fishincome <- variables %>%
  select(survey_id, country, community, income_fishing) %>%
  mutate(income_fishing = as.numeric(income_fishing)) %>%
  left_join(fishincome) %>%
  mutate(gf_fishincome = ifelse(is.na(income_fishing), 1, 0)) %>% 
  mutate(income_fishing = ifelse(is.na(income_fishing), mean_fishincome, 
                                 ifelse(income_fishing == 0, mean_fishincome, income_fishing))) %>% 
  select(survey_id, country, community, income_fishing)

```


```{r}
#education
variables_edu <- variables %>% 
  select(survey_id, country, community, education) %>%  
  mutate(education = as.character(education)) %>% 
  mutate(education = ifelse(education == "other", "secondary", education)) %>%
  mutate(education = case_when(
    education == "no_formal" ~ "no_formal",
    education == "primary" | education == "secondary" ~ "formal",
    education == "university" | education == "vocational" ~ "higher"
  )) %>%
  mutate(education = as.factor(education))
```

```{r}
#gapfill means for each village for variable "fishing_org_members"... except for MNC.. gapfill with overall indonesia mean 
# 61.86538 is the average fishing org size from survey in IND round up to 62 

members_group <- variables %>%
  select(survey_id, country, community, fishing_org_members) %>%
  group_by(community) %>%
  summarise(mean_mem = round(mean(fishing_org_members, na.rm = TRUE),0))

variables_members <- variables %>%
  select(survey_id, country, community, fishing_org_members) %>%
  mutate(fishing_org_members = as.numeric(fishing_org_members)) %>%
  left_join(members_group) %>%
  mutate(gapfill_members = ifelse(is.na(fishing_org_members), 1, 0),
         fishing_org_members = case_when(
           is.na(fishing_org_members) & community != "MNC" ~ mean_mem,
           is.na(fishing_org_members & community == "MNC") ~ 62, 
           !is.na(fishing_org_members) ~ fishing_org_members)) %>%
      select(survey_id, country, community, fishing_org_members)

```

```{r}
## tidy up fishtech variable... combine into one.. they have exposure to a type of fishing technology, or they don't.

variables_fishtech <- variables %>%
    select(survey_id, country, community, starts_with("fishtech")) %>%
  mutate(fishtech = ifelse(fishtech_none == 1, 0, 1),
         fishtech = ifelse(is.na(fishtech_none), 0, fishtech)) %>%
        mutate(fishtech = ifelse(fishtech_vhf == 1 & fishtech == 0, 1, fishtech),
               fishtech = ifelse(is.na(fishtech_vhf), 0 , fishtech)) %>%
  select(survey_id, country, community, fishtech)


#new <- variables_fishtech %>% filter(fishtech_vhf == 1, sum(5:9) == 0)
```



Combining corrected variables (income and education) with years_fishing, age, community

```{r}
avg_years_fish_by_country <- variables %>%
  group_by(country) %>%
  summarise(mean(years_fishing)) ## use this value to gapfill for the one case where years_fishing > age... works because the mean is less than the age. 

variables_fishing_years <-
  variables %>%
  select(survey_id, country, community, years_fishing, age) %>%
  mutate(years_fishing = ifelse(years_fishing > age, 22.5, years_fishing))
```

simplify boat ownership 
```{r}
variables_boat_own <- variables %>% 
  mutate(boat_own = ifelse(boat_status == "own", 1,0)) %>% 
  select(survey_id, boat_own)
```

```{r}
problems<-variables %>% 
  select(survey_id, community, rank_one) %>% 
  mutate(rank = as.factor(rank_one)) %>% 
  group_by(community) %>% 
  count(rank)
#RAJ= MAX(weather), total NA = 4
#WKB =  MAX(IUU), total NA = 1

variables_rankone<-variables %>% 
  select(survey_id, community, rank_one) %>%
  mutate(rank_one = ifelse(is.na(rank_one) & community == "RAJ", "weather", 
                           ifelse(is.na(rank_one) & community =="WKB", "iuu", rank_one)))
```

```{r}
variables_log<-variables %>% 
  select(survey_id, country, community, years_fishing, age, boat_length_m, fishing_organization) %>% 
  left_join(variables_edu) %>% 
  left_join(gdp_prop) %>%
  left_join(variables_members) %>%
  left_join(variables_fishtech) %>%
  left_join(variables_fishing_years) %>% 
  left_join(variables_boat_own) %>% 
  left_join(variables_fishincome) %>% 
  left_join(variables_rankone)

#write.csv(variables_log, "int/log_log_variables.csv", row.names = FALSE)

```



```{r}
#variables_log <- read_csv("int/log_log_variables.csv")
#bind_log <- read_csv("int/log_log_wtp.csv")


bind_log_final <- bind_log %>%
  left_join(variables_log) %>%
  within(own <- relevel(own, ref = 4)) %>%
  within(education <- relevel(education, ref = "no_formal"))

wtpmin<- min(bind_log_final$wtp)

```

```{r}
#hicksian demand test

# bind_log_hicksian <- bind_wtp %>% 
#   #filter(choice == 1) %>% 
#   mutate(sos = ifelse(sos==1,0,1)) %>% 
#   mutate(info = ifelse(info == 2,0,1)) %>% 
#   mutate(own = as.factor(own))
# 
# bind_log_hicksian_final <-  bind_log_hicksian %>%
#   left_join(variables_log) %>%
#   within(own <- relevel(own, ref = 4)) %>%
#   within(education <- relevel(education, ref = "no_formal")) %>%
#   rename("bid" = "wtp")

# mylogit <- glm(choice ~ bid + sos + info + own + education + fishtech + rank_one, data = bind_log_hicksian_final, family = "binomial")
# save(mylogit, file = "output/hicksian.rda")
# 
# summary(mylogit, clusters = c("community"))
# mylogit_rows <- c(names(mylogit$coefficients))
# 
# coef_binom <- data.frame(mylogit_rows, coefs_logit = mylogit$coefficients) %>%
#   mutate(coefs_wtp_model = coefs_logit/mylogit$coefficients[2])
```

Include new summary function that incorporates clusters
```{r}
# load necessary packages for importing the function
library(RCurl)
 
# import the function from repository
url_robust <- "https://raw.githubusercontent.com/IsidoreBeautrelet/economictheoryblog/master/robust_summary.R"
eval(parse(text = getURL(url_robust, ssl.verifypeer = FALSE)),
     envir=.GlobalEnv)
```

Prep data for interval regression
```{r}
## Make it into interval data... and run models again.. without log..


# For IND
# wtp_1 = $2.14
# wtp_2 = $3.56
# wtp_3 = $5.35
# wtp_4 = $7.12

# For MEX 
# wtp_1 = $2.07
# wtp_2 = $3.62
# wtp_3 = $5.17
# wtp_4 = $7.75


#wtp == -100, -7.75,

bind_interval_mex <- bind_log_final %>% 
  filter(country == "MEX") %>%
  mutate(wtp_upper = 
                    ifelse(wtp == -7.75, -5.17, 
                       ifelse(wtp == -5.17, -3.62,
                              ifelse(wtp == -3.62, -2.07,
                                      ifelse(wtp == -2.07, 0,
                                             ifelse(wtp == 0, 2.07, 
                                                    ifelse(wtp == 2.07, 3.62,
                                                           ifelse(wtp == 3.62, 5.17,
                                                                  ifelse(wtp == 5.17, 7.75, 13.33))))))))) ## chose 13.33 as the upper bound because this is two cell phone bill increments higher than 7.75
                                                                        
#ifelse(wtp == -100, -7.12,                                                                       
 bind_interval_ind <- bind_log_final %>%
       filter(country == "IND") %>%
   mutate(wtp_upper = 
          ifelse(wtp == -7.12, -5.35,
            ifelse(wtp == -5.35, -3.56, 
              ifelse(wtp == -3.56, -2.14,
                ifelse(wtp == -2.14, 0, 
                  ifelse(wtp == 0, 2.14, 
                    ifelse(wtp == 2.14, 3.56, 
                      ifelse(wtp == 3.56, 5.35, 
                        ifelse(wtp == 5.35, 7.12, 11.02))))))))) ## chose 11.02 as the upper bound because this is two cell phone bill increments higher than 7.12
  

bind_interval_final <- rbind(bind_interval_ind, bind_interval_mex) %>%
  rename("wtp_lower" = "wtp") 

intervals <- with(bind_interval_final, Surv(wtp_lower, wtp_upper, event = rep(3, nrow(bind_interval_final)), type = "interval"))
intervals

```

Run regressions on interval data
```{r}
int_tech <- survreg(intervals ~ sos + info + own, data = bind_interval_final, dist = "gaussian")
summary(int_tech)

int <- survreg(intervals ~ sos + info + own + education + gdp_prop, data = bind_interval_final, dist = "gaussian")
summary(int)

int_1 <- survreg(intervals ~ sos + info + own + education + years_fishing, data = bind_interval_final, dist = "gaussian")
summary(int_1, cluster = c("community"))

int_2 <- survreg(intervals ~ sos + info + own + education + boat_length_m, data = bind_interval_final, dist = "gaussian")
summary(int_2, cluster = c("community"))

int_3 <- survreg(intervals ~ sos + info + own + education + boat_length_m + fishtech, data = bind_interval_final, dist = "gaussian")
summary(int_3, cluster = c("community"))

int_4 <- survreg(intervals ~ sos + info + own + education  + fishtech + gdp_prop, data = bind_interval_final, dist = "gaussian")
summary(int_4, cluster = c("community"))

int_5 <- survreg(intervals ~ sos + info + own + education + years_fishing + fishtech, data = bind_interval_final, dist = "gaussian")
summary(int_5, cluster = c("community"))

int_6 <- survreg(intervals ~ sos + info + own + education + years_fishing + gdp_prop + fishtech, data = bind_interval_final, dist = "gaussian")
summary(int_6, cluster = c("community"))

int_7 <- survreg(intervals ~ sos + info + own + education +  fishtech, data = bind_interval_final, dist = "gaussian")
summary(int_7, cluster = c("community"))

int_8 <- survreg(intervals ~ sos + info + own + gdp_prop +  fishtech, data = bind_interval_final, dist = "gaussian")
summary(int_8, cluster = c("community"))

int_9 <- survreg(intervals ~ sos + info + own + gdp_prop +  fishtech + boat_own, data = bind_interval_final, dist = "gaussian")
summary(int_9, cluster = c("community"))

int_10 <- survreg(intervals ~ sos + info + own + gdp_prop +  fishtech + fishing_organization, data = bind_interval_final, dist = "gaussian")
summary(int_10, cluster = c("community"))

int_11 <- survreg(intervals ~ sos + info + own + gdp_prop +  fishtech + income_fishing, data = bind_interval_final, dist = "gaussian")
summary(int_11, cluster = c("community"))

int_12 <- survreg(intervals ~ sos + info + own + gdp_prop +  fishtech + rank_one, data = bind_interval_final, dist = "gaussian")
summary(int_12, cluster = c("community"))

int_13 <- survreg(intervals ~ sos + info + own +  fishtech + rank_one + fishing_organization, data = bind_interval_final, dist = "gaussian")
summary(int_13, cluster = c("community"))

int_15 <- survreg(intervals ~ sos + info + own + rank_one + fishtech + education, data = bind_interval_final, dist = "gaussian") ## normal distribution... WTP does look normal
summary(int_15, cluster = c("community"))

int_16 <- survreg(intervals ~ sos + info + own + rank_one + fishtech + education + gdp_prop, data = bind_interval_final, dist = "gaussian") ## normal distribution... WTP does look normal
summary(int_16, cluster = c("community"))

#save(int_15, file = "output/int_15.rda")

#save(int_16, file = "output/int_16_gdp_prop.rda")

AIC(int_tech, int, int_1, int_2, int_3, int_4, int_5, int_6, int_7, int_8, int_9, int_10, int_11, int_12, int_13, int_15, int_16)
```


Run log-log and log-linear regressions on our data for WTP
```{r}
## Traditional linear regression:
basic_wtp_lm <- lm(wtp  ~ sos + info + own  + fishtech + factor(country) + rank_one + gdp_prop, data = bind_log_final)
summary(basic_wtp_lm, cluster = c("community"))

#AIC score is 916.8084, which is 800+ higher than other models. So no to the linear model

## Test log-log models:
wtp_lm <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(gdp_prop) + education + factor(country), data = bind_log_final)
summary(wtp_lm, cluster = c("community"))
autoplot(wtp_lm, which = 1:6, ncol = 3, label.size = 3)

wtp_lm_1 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(years_fishing) + education + factor(country), data = bind_log_final)
summary(wtp_lm_1, cluster = "community")

wtp_lm_2 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(boat_length_m) + education + factor(country), data = bind_log_final)
summary(wtp_lm_2, cluster = "community")

wtp_lm_3 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(boat_length_m) + education + fishtech + factor(country), data = bind_log_final) 
summary(wtp_lm_3, cluster = "community")

wtp_lm_4 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(gdp_prop) + education + fishtech + factor(country), data = bind_log_final) 
summary(wtp_lm_4, cluster = "community")

wtp_lm_5 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(years_fishing) + education + fishtech + factor(country), data = bind_log_final)
summary(wtp_lm_5, cluster = c("community"))

wtp_lm_6 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(gdp_prop) + log(years_fishing) + education + fishtech + factor(country), data = bind_log_final) 
summary(wtp_lm_6, cluster = "community")

wtp_lm_7 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + education + fishtech + factor(country), data = bind_log_final) 
summary(wtp_lm_7, cluster = "community")

wtp_lm_8 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(gdp_prop) + fishtech + factor(country), data = bind_log_final) 
summary(wtp_lm_8, cluster = "community")

wtp_lm_9 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(gdp_prop) + fishtech + factor(country) + boat_own, data = bind_log_final) 
summary(wtp_lm_9, cluster = "community")

wtp_lm_10 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + log(gdp_prop) + fishtech + factor(country) + fishing_organization, data = bind_log_final) 
summary(wtp_lm_10, cluster = "community")

wtp_lm_11 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech + factor(country) + log(gdp_prop) + log(income_fishing), data = bind_log_final) 
summary(wtp_lm_11, cluster = "community")

wtp_lm_12 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech + rank_one + log(gdp_prop), data = bind_log_final) 
summary(wtp_lm_12, cluster = "community")

wtp_lm_13 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech + factor(country) + rank_one + log(gdp_prop) + education, data = bind_log_final) 
summary(wtp_lm_13, cluster = "community")

wtp_lm_14 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech  + factor(country) + rank_one + education, data = bind_log_final) 
summary(wtp_lm_14, cluster = "community")

wtp_lm_15 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech + rank_one + education, data = bind_log_final) 
summary(wtp_lm_15, cluster = "community")

wtp_lm_16 <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech  + rank_one + log(gdp_prop) + education, data = bind_log_final) 
summary(wtp_lm_16, cluster = "community")
#save(wtp_lm_16, file = "output/wtp_lm_16_gdp_prop.rda")

AIC(basic_wtp_lm, wtp_lm, wtp_lm_1, wtp_lm_2, wtp_lm_3, wtp_lm_4, wtp_lm_5, wtp_lm_6, wtp_lm_7, wtp_lm_8, wtp_lm_9, wtp_lm_10, wtp_lm_11, wtp_lm_12, wtp_lm_13, wtp_lm_14, wtp_lm_15, wtp_lm_16) ## take the lowest one...  we will look at the best 3... 14, 15, 16


######## Random Hypotheses ########

## years_fishing adds more predictive power and has a lower p value than age -- use years_fishing 
## hypothesis: the longer someone has been fishing the more value they put into having this technology.

## income/gdp_prop: hypothesis: a higher income will place a higher value on the technology... model disagrees.. could have an interesting dialogue 

## education: a more educated person will likely want to pay more for this technology.. they will see more benefit in it. However, possible that we have some collinearity with education and income... should we debunk this? 

## fishing_org_members: hypothesis: a larger fishing organization size will place less value on tracking tech because they feel safer while fishing... more people around to help if something goes wrong. They also probably share more information with eachother anyways? <---- don't include this. Not all of our respondents were in a fishing organizatio..

## Test if education and income are correlated. 
ggplot(bind_log_final, aes(x = income_usd, y = wtp, color = education)) + geom_point() ## it seems that education vs income are pretty random... ok to both use in the model. 
```

Take a look at summary output (clustered on community) for our 3 best log models: 
```{r}

summary(wtp_lm_14, cluster = c("community"))

summary(wtp_lm_15, cluster = c("community"))

summary(wtp_lm_16, cluster = c("community"))

## save lm_15 
#save(wtp_lm_15, file = "output/lm_15.rda")

test_wtp <- lm(wtp ~ sos + info + own, data = bind_log_final)
summary(test_wtp, cluster = c("community"))

# new_bind <- bind_log_final %>%
#   mutate(rank_one = factor(rank_one)) %>%
#   within(rank_one <- relevel(rank_one, ref = "weather"))
# 
# wtp_lm_15_test <- lm(log(wtp + 1 - min(wtp)) ~ sos + info + own  + fishtech + rank_one + education, data = new_bind) 
# 
# summary(wtp_lm_15_test, cluster = c("community"))
```


Predict and retransform our models on our data just as a check
```{r}
## Predict values for our best models
predict_lm14 <- cbind(bind_log_final, fitted = fitted(wtp_lm_14)) %>% 
  mutate(wtp_predict = (exp(fitted) - 1 + min(wtp)))

predict_lm15 <- cbind(bind_log_final, fitted = fitted(wtp_lm_15)) %>% 
  mutate(wtp_predict = (exp(fitted) - 1 + min(wtp))) %>%
  select(survey_id, sos, info, own, wtp_predict, fishtech, education, rank_one)
 
predict_lm16 <- cbind(bind_log_final, fitted = fitted(wtp_lm_16)) %>% 
  mutate(wtp_predict = (exp(fitted) - 1 + min(wtp)))

int_15_predict <- data.frame(bind_interval_final, wtp_predict_int = int_15$linear.predictors) %>%
  select(survey_id, sos, info, own, wtp_predict_int, fishtech, education, rank_one)

## Compare log log regression and interval regression
test <- merge(predict_lm15, int_15_predict)
summary(test$wtp_predict) 
 # Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 # -1.234   1.250   2.236   2.309   3.463   6.117 

summary(test$wtp_predict_int) 
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# -0.2632  2.7588  3.7268  3.7003  4.6572  7.0105 
```


Look at exact percent changes in WTP per our categorical variables for our best models 
```{r}
# calculate exact percent change in WTP for our categorical variables for our best models
coef_lm_14 <- as.data.frame(wtp_lm_14$coefficients) %>%
  tibble::rownames_to_column("Beta") %>%
  mutate(on = exp(wtp_lm_14$coefficients) - 1 , off = exp(-wtp_lm_14$coefficients) - 1)

coef_lm_15 <- as.data.frame(wtp_lm_15$coefficients) %>%
  tibble::rownames_to_column("Beta") %>%
  mutate(on = exp(wtp_lm_15$coefficients) - 1 , off = exp(-wtp_lm_15$coefficients) - 1)

coef_lm_16 <- as.data.frame(wtp_lm_16$coefficients) %>%
  tibble::rownames_to_column("Beta") %>%
  mutate(on = exp(wtp_lm_16$coefficients) - 1 , off = exp(-wtp_lm_16$coefficients) - 1)

#write.csv(coef_lm_16, "output/wtp_results_16.csv", row.names = FALSE)

```

Run the best technology/best characteristics (BTBC), best tech/worst characteristics (BTWC), worst tech/best characteristics (WTBC), and worst tech/worst characteristics (WTWC) for log models 14, 15, and 16.
```{r}
#### Model 14
# best tech: sos = 1, info = 0, own = 1
# worst tech = sos = 0, info = 1, own = 4
# best characteristics: fishtech = 1, country = "IND", rankone = "corruption", education = "higher"
# worst characteristics: fishtech = 0, country = MEX, rankone = weather, education = noformal
rownames <- c("BTBC", "BTWC", "WTBC", "WTWC")

BTBC_14 <- data.frame(sos = 1, info =  0, own = as.factor(1), fishtech = 1, country = "IND", rank_one = "corruption", education = "higher")

BTWC_14 <- data.frame( sos = 1, info =  0, own = as.factor(1), fishtech = 0, country = "MEX", rank_one = "weather", education = "no_formal")

WTBC_14 <- data.frame( sos = 0, info =  1, own = as.factor(4), fishtech = 1, country = "IND", rank_one = "corruption", education = "higher")

WTWC_14 <- data.frame( sos = 0, info =  1, own = as.factor(4), fishtech = 0, country = "MEX", rank_one = "weather", education = "no_formal")

newdata_14 <- rbind(BTBC_14, BTWC_14, WTBC_14, WTWC_14)

predict_14 <- predict(wtp_lm_14, newdata = newdata_14)
predict_14 <- data.frame((exp(predict_14) - 1 + wtpmin))
row.names(predict_14) <- rownames
#### Model 15
# best tech: sos = 1, info = 0, own = 1
# worst tech = sos = 0, info = 1, own = 4
# best characteristics: fishtech = 1, rankone = "corruption", education = "higher"
# worst characteristics: fishtech = 0, rankone = weather, education = noformal


BTBC_15 <- data.frame(sos = 1, info =  0, own = as.factor(1), fishtech = 1,  rank_one = "corruption", education = "higher")

BTWC_15 <- data.frame( sos = 1, info =  0, own = as.factor(1), fishtech = 0, rank_one = "weather", education = "no_formal")

WTBC_15 <- data.frame( sos = 0, info =  1, own = as.factor(4), fishtech = 1, rank_one = "corruption", education = "higher")

WTWC_15 <- data.frame( sos = 0, info =  1, own = as.factor(4), fishtech = 0, rank_one = "weather", education = "no_formal")

newdata_15 <- rbind(BTBC_15, BTWC_15, WTBC_15, WTWC_15)

predict_15 <- predict(wtp_lm_15, newdata = newdata_15)
predict_15 <- data.frame((exp(predict_15) - 1 + wtpmin))
row.names(predict_15) <- rownames

#### Model 15
# best tech: sos = 1, info = 0, own = 1
# worst tech = sos = 0, info = 1, own = 4
# best characteristics: fishtech = 1, rankone = "corruption", education = "higher"
# worst characteristics: fishtech = 0, rankone = weather, education = noformal
mingdpprop <- min(bind_log_final$gdp_prop)
maxgdpprop <- max(bind_log_final$gdp_prop)

BTBC_16 <- data.frame(sos = 1, info =  0, own = as.factor(1), fishtech = 1,  rank_one = "corruption", gdp_prop = mingdpprop, education = "higher")

BTWC_16 <- data.frame( sos = 1, info =  0, own = as.factor(1), fishtech = 0, rank_one = "weather", gdp_prop = maxgdpprop, education = "no_formal")

WTBC_16 <- data.frame( sos = 0, info =  1, own = as.factor(4), fishtech = 1, rank_one = "corruption", gdp_prop = mingdpprop, education = "higher")

WTWC_16 <- data.frame( sos = 0, info =  1, own = as.factor(4), fishtech = 0, rank_one = "weather",gdp_prop = maxgdpprop, education = "no_formal")

newdata_16 <- rbind(BTBC_16, BTWC_16, WTBC_16, WTWC_16)


predict_16 <- predict(wtp_lm_16, newdata = newdata_16)
predict_16 <- data.frame((exp(predict_16) - 1 + wtpmin))
# predict_15 <- cbind(Row.Names = rownames(rownames), predict_15)
row.names(predict_16) <- rownames

three_models_predictions <- cbind(lm_14 = predict_14, lm_15 = predict_15, lm_16 = predict_16)

#write.csv(three_models_predictions, "output/best_worst_scenarios_models.csv")
```


### Ultimate Simulation
```{r}
sos <- c(0,1)
info <- c(0,1)
own <- c("1", "2", "3", "4")
fishtech <- c(0,1)
rank_one <- c("corruption", "pollution", "weather", "iuu")
education <- c("no_formal", "formal", "higher")

simulation_data <- expand.grid(sos = sos, info = info, own = own,fishtech =  fishtech, rank_one = rank_one, education = education)

simulation_all_lm15 <- data.frame(simulation_data, wtp_predict = exp(predict(wtp_lm_15, newdata = simulation_data)) - 1 + wtpmin) 

simulation_all_int_15 <- data.frame(simulation_data, wtp_predict_int = predict(int_15, newdata = simulation_data))

sims_log_int <- merge(simulation_all_lm15, simulation_all_int_15)
#write.csv(sims_log_int, "output/compare_log_int.csv")

## now we have a dataframe of every possible combination of our variables in lm_15 and a predicted wtp from lm_15...
#write.csv(simulation_all_lm15, "output/lm_15_allcombo_predictions.csv")
```

## Graphs of opt in per payment to fishers
```{r}
# read in total simulation data... all predictions of all combinations of WTP 
simulation_all_lm15 <- read_csv("output/lm_15_allcombo_predictions.csv") %>%
  select(-X1)

sim_total <- nrow(simulation_all_lm15)

## make a vector of payment values 
dollar_values <- seq(-3, 8, by = 0.01)

test_graph_df <- simulation_all_lm15 %>%
  merge(dollar_values) %>%
  mutate(opt_in = ifelse(wtp_predict > y, 0, 1 )) %>% ## if the wtp is greater than payment value, then they will opt out, otherwise, opt in
  arrange(opt_in)

test_group_df <- test_graph_df %>%
  group_by(y, opt_in) %>%
  tally() %>%
  filter(opt_in == 1) %>% ## filter for all opt ins...
  mutate(perc_opt_in = n/sim_total) %>% ##384 total scenarios
  ungroup()
  
## compare filtering for opt outs...
test_group_df_opt_out <- test_graph_df %>%
  group_by(y, opt_in) %>%
  tally() %>%
  filter(opt_in == 0) %>%
  mutate(perc_opt_in = n/sim_total) %>%
  ungroup()


#test_graph_df$cumperc <- ifelse(test_graph_df$opt_in == 0, 0, (1:nrow(test_graph_df))/nrow(test_graph_df))

#opt in graph
ggplot(test_group_df, aes(x = y, y = perc_opt_in)) +
  geom_point() +
  labs(x = "Payment to Fisher ($/month)", y = "Percent opt in VMS Program", title = "All Technology and Demographic Combinations") +
  theme_bw() +
  scale_x_continuous(breaks = seq(-3,8, 1))
  

#opt out graph
ggplot(test_group_df_opt_out, aes(x = y, y = perc_opt_in)) +
  geom_point() +
  labs(x = "Payment to Fisher ($/month)", y = "Percent opt out VMS Program", title = "All Technology and Demographic Combinations") +
  theme_bw() +
  scale_x_continuous(breaks = seq(-3,8, 1))

test_group_df %>%
  filter(perc_opt_in == 0.5)

test_group_df_opt_out %>%
  filter(perc_opt_in == 0.5)

mean(simulation_all_lm15$wtp_predict)

mean(bind_log$wtp)

mean(bind_wtp$wtp)

```




How to interpret our coefficients:
The coefficient on a dummy variable with a log-transformed Y variable is interpreted as the percentage change in Y associated with having the dummy variable characteristic relative to the omitted category, with all other included X variables held fixed.

Justification for using a log-log model:
For interpretation. In economics, we are sometimes interested how a percentage change in x affects the percentage change in y. This called elasticity. We can estimate elasticity (f) by using a log-log model


Notes and relevant links:

 - https://stats.stackexchange.com/questions/240572/log-log-regression-dummy-variable-and-index
 
 - https://rpubs.com/rslbliss/fixed_effects
 
 - https://blogs.sas.com/content/iml/2011/04/27/log-transformations-how-to-handle-negative-data-values.html
 
 - https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faqhow-do-i-interpret-a-regression-model-when-some-variables-are-log-transformed/

By controlling for female in the original equation, we are estimating the relationship between hours worked and weekly salary having adjusted for systematic differences in hours worked and weekly salary between females and males. (A bit wordy, yes, but this is my preferred interpretation.)

Fixed effects (in the context of this page) are just a fancy extension of the idea of controlling for a categorical variable.

As a presentation note, people often do not present the actual fixed effects estimates in their results. They often just note that fixed effects were included, but don’t present the actual numbers because they are not typically interpreted.





