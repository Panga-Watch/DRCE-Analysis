---
title: "Analysis"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
  pdf_document:
    toc: true
---

## Summary
Mixed Logit Analysis on the DRCE conducted in Indonesia and Mexico. Split into four different models; Standard opt-out model (Model I), Pooled (Model II), Unforced Responses (Model III), and Forced Responses (Model IV).

Will try to simulate both mixed logit and conditional logit models based off of this: https://cran.r-project.org/web/packages/mlogit/vignettes/c4.relaxiid.html
 
## Data Source 
Personal Interviews
 
## Reference 
Panga Watch
 
## Downloaded
September 30, 2019
 
Time range: 
2019
 
## Format
comma separated values

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(survival)
library(AlgDesign)
library(DT)
library(stargazer)
library(xtable)
library(here)
library(kableExtra)
#library(support.CEs)
#library("mlogit")
```

Standard opt-out model (Model I)
```{r}
standard_opt_out <- read_csv("int/standard_opt_out.csv") %>% 
  mutate(sos = ifelse(sos==2,1,0), info=ifelse(info==2,0,1)) %>%
  mutate(own.fisher=ifelse(own==1,1,0), own.industry=ifelse(own==2,1,0), own.gov=ifelse(own==3,1,0), own.public=ifelse(own==4,1,0))

write.csv(standard_opt_out, "int/standard_opt_out_fix.csv", row.names = FALSE)

standard_clogit<-clogit(RES~ASC+sos+info+own.fisher+own.industry+own.gov+own.public+strata(STR), data=standard_opt_out)
standard_clogit

standard_opt_out_wtp <- read_csv("int/standard_opt_out_wtp.csv") %>%
    mutate(sos = as.factor(sos), info = as.factor(info), own = as.factor(own), own.fisher = as.factor(own.fisher), own.industry = as.factor(own.industry), own.gov = as.factor(own.gov), own.public = as.factor(own.public)) %>%
  arrange(survey_id)
standard_wtp_clogit<-clogit(RES~ASC+sos+info+own.fisher+own.industry+own.gov+own.public +wtp+strata(STR), data=standard_opt_out_wtp)
standard_wtp_clogit

# mwtp(output = standard_opt_out_wtp, monetary.variables = c("wtp"), nonmonetary.variables =
#  c("sos", "info", "own.fisher", "own.industry", "own.gov", "own.public"),
#  percentile.points = c(5, 95), seed = 987)
```

Pooled (Model II)
```{r}
pooled <- read_csv("int/pooled_data.csv")%>% 
  mutate(sos = ifelse(sos==2,1,0), info=ifelse(info==2,0,1)) %>%
  mutate(own.fisher=ifelse(own==1,1,0), own.industry=ifelse(own==2,1,0), own.gov=ifelse(own==3,1,0), own.public=ifelse(own==4,1,0))
write.csv(pooled, "int/pooled_data_fix.csv", row.names = FALSE)

pooled_clogit<-clogit(RES~sos+info+own.fisher+own.industry+own.gov+own.public+strata(STR), data=pooled)
pooled_clogit
```

Unforced Responses (Model III)
```{r}
unforced <- read_csv("int/unforced_data.csv")%>% 
  mutate(sos = ifelse(sos==2,1,0), info=ifelse(info==2,0,1)) %>%
  mutate(own.fisher=ifelse(own==1,1,0), own.industry=ifelse(own==2,1,0), own.gov=ifelse(own==3,1,0), own.public=ifelse(own==4,1,0))

write.csv(unforced, "int/unforced_fix.csv", row.names = FALSE)

unforced_clogit<-clogit(RES~sos+info+own.fisher+own.industry+own.gov+own.public+strata(STR), data=unforced)
unforced_clogit
```

Forced Responses (Model IV)
```{r}
forced <- read_csv("int/forced_data.csv")%>% 
  mutate(sos = ifelse(sos==2,1,0), info=ifelse(info==2,0,1)) %>%
  mutate(own.fisher=ifelse(own==1,1,0), own.industry=ifelse(own==2,1,0), own.gov=ifelse(own==3,1,0), own.public=ifelse(own==4,1,0))

write.csv(forced, "int/forced_fix.csv", row.names = FALSE)

forced_clogit<-clogit(RES~sos+info+own.fisher+own.industry+own.gov+own.public+strata(STR), data=forced)
forced_clogit
summary(forced_clogit)
```

```{r}
#K = 5
#M = 2

pooled_log <- logLik(pooled_clogit) #-74.11078 (df=5)
unforced_log <- logLik(unforced_clogit) #-42.90397 (df=5)
forced_log <- logLik(forced_clogit) #-22.24721 (df=5)

-2*(logLik(pooled_clogit) - (logLik(unforced_clogit) + logLik(forced_clogit)))
-2*(pooled_log- (unforced_log + forced_log))

-2*(74.11078 - (42.90397 + 22.24721)) #17.9192
# if this then 17.9192 < 20.52 which means that we do not reject the null that there is no difference between the forced and unforced...........
```


```{r}
#predictions for pooled data

library(AlgDesign)
ffd <- gen.factorial(c(2,2,4), varNames = c("sos", "info", "own"), factors = "all") # construct a full factorial design which has two 2 level attributes and one 4 level attribute. factors = "all" indicates that all arguments are factors
ffd 

all_packages <- ffd %>%
  mutate(STR = 1001, package = 1:16) %>% 
  mutate(sos = ifelse(sos==2,1,0), info=ifelse(info==2,0,1)) %>%
  mutate(own.fisher=ifelse(own==1,1,0), own.industry=ifelse(own==2,1,0), own.gov=ifelse(own==3,1,0), own.public=ifelse(own==4,1,0)) 

pooled_predictions <- predict(pooled_clogit, newdata = all_packages, type = "risk", se.fit = TRUE)

pooled_predictions_data <- data.frame(all_packages, pooled_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	1 = no, 2 = yes
# info 	1 = non, 2 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

pooled_predictions_data <- pooled_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(package, info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(pooled_predictions_data, "output/pooled_probs.csv", row.names = FALSE)

DT::datatable(pooled_predictions_data)
```


```{r}
#forced predictions 

forced_predictions <- predict(forced_clogit, newdata = all_packages, type = "risk", se.fit = TRUE)

forced_predictions_data <- data.frame(all_packages, forced_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	0 = no, 1 = yes
# info 	0 = non, 1 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

forced_predictions_data <- forced_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(package, info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(forced_predictions_data, "output/forced_probs.csv", row.names = FALSE)

DT::datatable(forced_predictions_data)
```

```{r}
#unforced predictions 

unforced_predictions <- predict(unforced_clogit, newdata = all_packages, type = "risk", se.fit = TRUE)

unforced_predictions_data <- data.frame(all_packages, unforced_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	0 = no, 1 = yes
# info 	0 = non, 1 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

unforced_predictions_data <- unforced_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(package, info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(unforced_predictions_data, "output/unforced_probs.csv", row.names = FALSE)

DT::datatable(unforced_predictions_data)
```

```{r}
#standard predictions
all_packages_standard <- all_packages %>%
  mutate(ASC = 1)
standard_predictions <- predict(standard_clogit, newdata = all_packages_standard, type = "risk", se.fit = TRUE)

standard_predictions_data <- data.frame(all_packages, standard_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	0 = no, 1 = yes
# info 	0 = non, 1 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

standard_predictions_data <- standard_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(package, info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(standard_predictions_data, "output/standard_probs.csv", row.names = FALSE)


DT::datatable(standard_predictions_data)
```


