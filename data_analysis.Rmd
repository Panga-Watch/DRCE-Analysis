---
title: "Analysis"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
  pdf_document:
    toc: true
---

## Summary
Mixed Logit Analysis on the DRCE conducted in Indonesia and Mexico. Split into four different models; Standard opt-out model (Model I), Pooled (Model II), Unforced Responses (Model III), and Forced Responses (Model IV).

## Data Source 
Personal Interviews
 
## Reference 
Panga Watch
 
## Downloaded
September 30, 2019
 
Time range: 
2019
 
## Format
comma separated values

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(survival)
library(AlgDesign)
library(DT)
library(stargazer)
library(xtable)
library(here)
library(kableExtra)
#library(support.CEs)
#library("mlogit")

master_survey <- read_csv("raw/master_survey_resp.csv") %>%
  select(-start, -end, -survey_type, -survey_version, -interviewer, -comment, -text_vms_adoption, -fishery_problem_one, -fishery_problem_two, -fishery_problem_three, -fishery_solution_one, -fishery_solution_two, -fishery_solution_three, -last_commends, -photo)
```

Standard opt-out model (Model I)
```{r}
standard_opt_out <- read_csv("int/standard_opt_out_fix.csv") %>%
  left_join(master_survey, by = "survey_id") %>%
  select(-noalt)
## Now we have ALL of the characteristics matched with each survey respondent and the correct data structure to plug into clogit. All you have to do is add whatever characteristic you want to the clogit function... i.e. age, years fishing, sex, village, etc... although I think you would have to add something like sos:country to determine the effect that country has on the sos attribute... meaning we would have to do this for every attribute for every characteristic if we use clogit... see below.

## Also could be useful to ask JM how to sus out the marginal effect on the probability of adoption by changing one attribute... still unclear how to do this to me. 

standard_clogit <- clogit(RES~ASC+sos+info+own.fisher+own.industry+own.gov + strata(STR), data=standard_opt_out)
standard_clogit

standard_clogit_char_test <- clogit(RES~ASC+sos+info+own.fisher+own.industry+own.gov + sos:country + info:country + own.fisher:country  + strata(STR), data=standard_opt_out)
standard_clogit_char_test

```

Pooled (Model II)
```{r}
pooled <- read_csv("int/pooled_data_fix.csv") %>%
  left_join(master_survey, by = "survey_id") %>%
  select(-noalt)
pooled_clogit<-clogit(RES~sos+info+own.fisher+own.industry+own.gov+strata(STR), data=pooled)
pooled_clogit
```

Unforced Responses (Model III)
```{r}
unforced <- read_csv("int/unforced_data_fix.csv") %>%
  left_join(master_survey, by = "survey_id") %>%
  select(-noalt)

unforced_clogit<-clogit(RES~sos+info+own.fisher+own.industry+own.gov+strata(STR), data=unforced)
unforced_clogit
```

Forced Responses (Model IV)
```{r}
forced <- read_csv("int/forced_data_fix.csv") %>%
  left_join(master_survey, by = "survey_id") %>%
  select(-noalt)

forced_clogit<-clogit(RES~sos+info+own.fisher+own.industry+own.gov+own.public+strata(STR), data=forced)
forced_clogit
```

```{r}
#K = 5
#M = 2

pooled_log <- logLik(pooled_clogit) #-74.11078 (df=5)
unforced_log <- logLik(unforced_clogit) #-42.90397 (df=5)
forced_log <- logLik(forced_clogit) #-22.24721 (df=5)

-2*(logLik(pooled_clogit) - (logLik(unforced_clogit) + logLik(forced_clogit)))
-2*(pooled_log- (unforced_log + forced_log))

-2*(74.11078 - (42.90397 + 22.24721)) #17.9192
# if this then 17.9192 < 20.52 which means that we do not reject the null that there is no difference between the forced and unforced...........
```


```{r}
#predictions for pooled data

library(AlgDesign)
ffd <- gen.factorial(c(2,2,4), varNames = c("sos", "info", "own"), factors = "all") # construct a full factorial design which has two 2 level attributes and one 4 level attribute. factors = "all" indicates that all arguments are factors
ffd 

all_packages <- ffd %>%
  mutate(STR = 1001) %>% 
  mutate(sos = ifelse(sos==2,1,0), info=ifelse(info==2,0,1)) %>%
  mutate(own.fisher=ifelse(own==1,1,0), own.industry=ifelse(own==2,1,0), own.gov=ifelse(own==3,1,0), own.public=ifelse(own==4,1,0)) 

pooled_predictions <- predict(pooled_clogit, newdata = all_packages, type = "risk", se.fit = TRUE)

pooled_predictions_data <- data.frame(all_packages, pooled_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	1 = no, 2 = yes
# info 	1 = non, 2 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

pooled_predictions_data <- pooled_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(pooled_predictions_data, "output/pooled_probs.csv", row.names = FALSE)

DT::datatable(pooled_predictions_data)
```


```{r}
#forced predictions 

forced_predictions <- predict(forced_clogit, newdata = all_packages, type = "risk", se.fit = TRUE)

forced_predictions_data <- data.frame(all_packages, forced_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	0 = no, 1 = yes
# info 	0 = non, 1 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

forced_predictions_data <- forced_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(forced_predictions_data, "output/forced_probs.csv", row.names = FALSE)

DT::datatable(forced_predictions_data)
```

```{r}
#unforced predictions 

unforced_predictions <- predict(unforced_clogit, newdata = all_packages, type = "risk", se.fit = TRUE)

unforced_predictions_data <- data.frame(all_packages, unforced_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	0 = no, 1 = yes
# info 	0 = non, 1 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

unforced_predictions_data <- unforced_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(unforced_predictions_data, "output/unforced_probs.csv", row.names = FALSE)

DT::datatable(unforced_predictions_data)
#0.9881482 

p = (exp(unforced_clogit$coefficients[1]*1 + unforced_clogit$coefficients[2]*1 + unforced_clogit$coefficients[3]*1 + unforced_clogit$coefficients[4]*0 + unforced_clogit$coefficients[5]*0))/(1 + exp( unforced_clogit$coefficients[1]*1+ unforced_clogit$coefficients[2]*1 + unforced_clogit$coefficients[3]*1 + unforced_clogit$coefficients[4]*0+ unforced_clogit$coefficients[5]*0))
p     
#0.9881482 


unforced_clogit

```

```{r}
#standard predictions
all_packages_standard <- all_packages %>%
  mutate(ASC = 1) 
standard_predictions <- predict(standard_clogit, newdata = all_packages_standard, type = "risk", se.fit = TRUE)

standard_predictions_data <- data.frame(all_packages, standard_predictions)  

#reasoning for predicting out a clogit model:
#https://markmail.org/search/?q=list%3Aorg.r-project.r-help+predict+clogit#query:list%3Aorg.r-project.r-help%20predict%20clogit%20from%3A%22Therneau%2C%20Terry%20M.%2C%20Ph.D.%22+page:1+mid:tsbl3cbnxywkafv6+state:results
#https://stackoverflow.com/questions/35329585/how-to-get-fitted-values-from-clogit-model

# sos	0 = no, 1 = yes
# info 	0 = non, 1 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline

standard_predictions_data <- standard_predictions_data %>%
  mutate(level_probs1 = fit/(fit+ 1),
         level_se = se.fit/(se.fit + 1)) %>%
  select(-fit, -se.fit, -STR) %>%
  arrange(-level_probs1) %>%
  select(info, own, sos, level_probs1, level_se) %>%
  mutate(info = case_when(
    info == 0 ~ "Anon",
    info == 1 ~ "Non-Anon"
  ), 
  own = case_when(
   own == 1 ~ "Fishers",
   own == 2 ~ "Industry", 
   own == 3 ~ "Government", 
   own == 4 ~ "Public Access"
  ),
  sos = case_when(
    sos == 0 ~ "No",
    sos == 1 ~ "Yes"
  ))

write.csv(standard_predictions_data, "output/standard_probs.csv", row.names = FALSE)


DT::datatable(standard_predictions_data)

standard_clogit

p = (exp(standard_clogit$coefficients[1]*1 + standard_clogit$coefficients[2]*1 + standard_clogit$coefficients[3]*1 + standard_clogit$coefficients[4]*1 + standard_clogit$coefficients[5]*0 + standard_clogit$coefficients[6]*0))/(1 + exp( standard_clogit$coefficients[1]*1+ standard_clogit$coefficients[2]*1 + standard_clogit$coefficients[3]*1 + standard_clogit$coefficients[4]*1+ standard_clogit$coefficients[5]*0 + standard_clogit$coefficients[6]*0))
p     

```

Look at probability differences between individual attributes... i.e. holding everything else constant. Compare it to most likely package for GFW to implement... Non Anonymous, Public Ownership, and SOS button.





